-- module ParseSpec
--   ( rubric,
--   )
-- where
-- import Control.Applicative ((<$>))
-- import Control.Monad.State
-- import Data.Function (on)
-- import Data.List (sortBy)
-- import Data.Maybe (fromJust, isJust)
-- import Expr
-- -- import Language.ECMAScript3.Parser (expression, parse)
-- -- import Logic
-- -- import Nano hiding (check)
-- import qualified Parse
-- import System.IO (readFile)
-- import Test.HUnit
-- import Test.Hrubric
-- import Test.Hspec
-- -- import Util
-- -- import Prelude hiding (and, or, seq)
-- rubric :: Rubric
-- rubric = do
--   let add = BinOp Add
--   let sub = BinOp Sub
--   let mul = BinOp Mul
--   let unwrap (Right x) = x
--       unwrap (Left x) = error . show $ x
--   -- Expressions
--   let e0 = "x + 1"
--   let e1 = "x * (y + 15 * 23) * (-3)"
--   -- In syntax tree format
--   let e0' = add (Var "x") (ConstI 1)
--   let e1' = mul (mul (Var "x") (add (Var "y") (mul (Const 15) (Const 23)))) (sub (Const 0) (Const 3))
--   passes "expr" (2 / 6) $ do
--     expr e0 @?= Just e0'
--     expr e1 @?= Just e1'
--   -- Boolean Expressions
--   let p0 = concat [e0, ">=", e1]
--   -- In syntax tree format
--   let p0' = Pred $ e0' :>=: e1'
--   passes "predicate" (0.5 / 6) $ do
--     predicate p0 @?= Just p0'
--   -- Boolean Expressions
--   let b0 = concat [e0, ">=", e1, "&& !true"]
--   -- In syntax tree format
--   let b0' = Pred (e0' :>=: e1') <> neg true
--   passes "logic" (0.5 / 6) $ do
--     logic b0 @?= Just b0'
--   criterion "statement" (3 / 6) . distribute $ do
--     let fileText = readFile file
--     let parse fileText = (normalize <$>) <$> Parse.funcParser "placeholder" fileText
--     let check fileText func = dpasses ("correctly parses " <> fileText) $ do
--           nano file `shouldReturn` return func
--     check
--       "programs/pos/abs.js"
--       [ Function
--           { fname = "abs",
--             fargs = ["x"],
--             fpre = true,
--             fpost = true,
--             fmods = [],
--             fbody =
--               Seq
--                 [ Assign "res" (Const 0),
--                   If
--                     (Pred $ Var "x" :>=: Const 1)
--                     (Assign "res" (Var "x"))
--                     (Assign "res" (sub (Const 0) (Var "x"))),
--                   Assert . Pred $ Var "res" :>=: Const 0
--                 ]
--           }
--       ]
-- --     check
-- --       "programs/pos/while5.js"
-- --       [ Function
-- --           { fname = "foo",
-- --             fargs = [],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "x" $ Const 0,
-- --                   While
-- --                     (Pred $ Var "x" :<=: Const 6)
-- --                     (Pred $ Var "x" :<=: Const 5)
-- --                     (Assign "x" (add (Var "x") (Const 1))),
-- --                   Assert . Pred $ Var "x" :==: Const 6
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/pos/ifassert.js"
-- --       [ Function
-- --           { fname = "ifassert",
-- --             fargs = ["x", "y"],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "lock" (Const 0),
-- --                   If
-- --                     (Pred $ Var "x" :>=: Const 1)
-- --                     ( Seq
-- --                         [ Assign "lock" (Const 1),
-- --                           Assert $ And [Pred $ Var "lock" :>=: Const 1, Pred $ Var "x" :>=: Const 1]
-- --                         ]
-- --                     )
-- --                     skip,
-- --                   If
-- --                     (Pred $ Var "y" :>=: Const 1)
-- --                     ( Seq
-- --                         [ Assign "lock" (Const 0),
-- --                           Assert $ And [Pred $ Var "lock" :<=: Const 0, Pred $ Var "y" :>=: Const 1]
-- --                         ]
-- --                     )
-- --                     skip
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/sum3.js"
-- --       [ Function
-- --           { fname = "sum",
-- --             fargs = ["n"],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "i" (Const 1),
-- --                   Assign "sum" (Const 0),
-- --                   While
-- --                     (Pred $ Var "i" :>=: Const 0)
-- --                     (Pred $ Var "n" :>=: Var "i")
-- --                     ( Seq
-- --                         [ Assign "j" (Const 1),
-- --                           While
-- --                             (Neg . Pred $ Var "i" :>=: Const 0)
-- --                             (Pred $ Var "i" :>=: Var "j")
-- --                             ( Seq
-- --                                 [ Assign "sum" (add (Var "sum") (Var "j")),
-- --                                   Assign "j" (add (Var "j") (Const 1)),
-- --                                   Assign "i" (add (Var "i") (Const 1))
-- --                                 ]
-- --                             ),
-- --                           Assert . Pred $ Var "sum" :>=: Const 0
-- --                         ]
-- --                     )
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/abs.js"
-- --       [ Function
-- --           { fname = "abs",
-- --             fargs = ["x"],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "res" (Const 0),
-- --                   If
-- --                     (Pred $ Var "x" :>=: Const 1)
-- --                     (Assign "res" (Var "x"))
-- --                     (Assign "res" (sub (Const 0) (Var "x"))),
-- --                   Assert . Pred $ Var "res" :>=: Const 1
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/while5-false.js"
-- --       [ Function
-- --           { fname = "foo",
-- --             fargs = [],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "x" (Const 0),
-- --                   While
-- --                     (Pred $ Var "x" :<=: Const 6)
-- --                     (Pred $ Var "x" :<=: Const 5)
-- --                     (Assign "x" (add (Var "x") (Const 1))),
-- --                   Assert . Pred $ Var "x" :==: Const 5
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/while5-noninductive.js"
-- --       [ Function
-- --           { fname = "foo",
-- --             fargs = [],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "x" (Const 0),
-- --                   While
-- --                     (Pred $ Var "x" :<=: Const 5)
-- --                     (Pred $ Var "x" :<=: Const 5)
-- --                     (Assign "x" (add (Var "x") (Const 1)))
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/fun3.js"
-- --       [ Function
-- --           { fname = "f",
-- --             fargs = ["x"],
-- --             fpre = Pred $ Var "x" :>=: Const 0,
-- --             fpost = Pred $ Var "$result" :>=: Const 2,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ Assign "x" $ BinOp Add (Var "x") (Const 2),
-- --                   Return $ Var "x"
-- --                 ]
-- --           },
-- --         Function
-- --           { fname = "c",
-- --             fargs = ["x"],
-- --             fpre = true,
-- --             fpost = Pred $ Var "$result" :>=: Const 2,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ AppAsn "y" "f" [Var "x"],
-- --                   Return $ Var "y"
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/pos/modifies1.js"
-- --       [ Function
-- --           { fname = "f",
-- --             fargs = [],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ ArrAsn "a" (Const 0) (Const 1),
-- --                   AppAsn "x" "g" [Var "a"],
-- --                   Assert . Pred $ Select (Array "a") (Const 1) :==: Const 2
-- --                 ]
-- --           },
-- --         Function
-- --           { fname = "g",
-- --             fargs = ["a"],
-- --             fpre = true,
-- --             fpost = Pred $ Select (Array "a") (Const 1) :==: Const 2,
-- --             fmods = ["a"],
-- --             fbody =
-- --               Seq
-- --                 [ ArrAsn "a" (Const 1) (Const 2),
-- --                   Return $ Const 0
-- --                 ]
-- --           }
-- --       ]
-- --     check
-- --       "programs/neg/modifies.js"
-- --       [ Function
-- --           { fname = "f",
-- --             fargs = [],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ ArrAsn "a" (Const 0) (Const 1),
-- --                   AppAsn "x" "g" [Var "a"],
-- --                   Assert . Pred $ Select (Array "a") (Const 0) :==: Const 1
-- --                 ]
-- --           },
-- --         Function
-- --           { fname = "g",
-- --             fargs = ["a"],
-- --             fpre = true,
-- --             fpost = true,
-- --             fmods = ["a"],
-- --             fbody = Return $ Const 0
-- --           }
-- --       ]
-- --     check
-- --       "programs/pos/fun7.js"
-- --       [ Function
-- --           { fname = "f",
-- --             fargs = ["x", "y"],
-- --             fpre = true,
-- --             fpost = Neg . Pred $ Var "$result" :>=: Const 0,
-- --             fmods = [],
-- --             fbody =
-- --               Seq
-- --                 [ If
-- --                     (Neg . Pred $ Var "y" :<=: Const 0)
-- --                     (Return $ sub (Const 0) (Const 7))
-- --                     (Seq []),
-- --                   Return $ sub (Const 0) (Const 1)
-- --                 ]
-- --           }
-- --       ]
{-# OPTIONS_GHC -F -pgmF htfpp #-}

module ParseSpec
  ( -- some more exports here

    htf_thisModulesTests, -- all test cases are automatically collected in htf_thisModulesTests
  )
where

import Parse
import Test.Framework

-- Each top-level definition whose name starts with test_ defines a unit test.
test_nonEmpty :: Assertion
test_nonEmpty = do
  assertEqual "Error" (parserMain "programs/neg/div1.txt")